<!DOCTYPE html>
<html>
  <head>
    <title>mdns &#8212; User Guide</title>
    <link rel="stylesheet" href="./stylesheets/mdns.css" type="text/css"/>
  </head>
  <body>
    <div id="page">
      <header>
        <nav>
          <ul>
            <li><a href="./index.html">Home</a></li>
            <li><a href="./user_guide.html">User Guide</a></li>
            <li><a href="http://github.com/agnat/node_mdns">GitHub</a></li>
          </ul>
        </nav>
      </header>
      <div id="content">
        <h1>mdns User Guide</h1>
<ul id="toc">
	<li><a href="#introduction">Introduction</a></li>
	<li><a href="#tutorial">Tutorial</a>
	<ul>
		<li><a href="#service_types">On service types</a></li>
		<li><a href="#resolver_sequence">The resolver sequence</a></li>
	</ul></li>
	<li><a href="#reference">Reference</a>
	<ul>
		<li><a href="#advertisement" title="">mdns.Advertisement</a></li>
		<li><a href="#browser" title="">mdns.Browser</a></li>
		<li><a href="#rst">Resolver sequence tasks</a></li>
		<li><a href="#service_type">mdns.ServiceType</a></li>
		<li><a href="#functions">Functions</a></li>
		<li><a href="#constants">Constants</a></li>
		<li><a href="#dns_sd">mdns.dns_sd</a></li>
	</ul></li>
	<li><a href="#design_notes">Design Notes</a></li>
	<li><a href="#compatibility">Compatibility Notes</a></li>
	<li><a href="#further_reading">Further Reading</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>mdns adds support for multicast <span class="caps">DNS</span> service discovery, also known as zeroconf or bonjour to node.js. It provides an object based interface to announce and browse services on the local network.</p>
<p>Internally, it uses the dns_sd <span class="caps">API</span> which is available on all major platforms. However, that does not mean it is equally well supported on all platforms. See <a href="#compatibility">Compatibility Notes</a> for more information.</p>
<p>The <span class="caps">API</span> is documented in the <a href="#reference">reference section</a> below.</p>
<h2 id="tutorial">Tutorial</h2>
<p>Before we begin go to the internet and get you a <em>bonjour browser</em> so that you can <em><span class="caps">ALL</span></em> the service discovery.</p>
<p>Multicast <span class="caps">DNS</span> service discovery provides a way to announce and discover services on the local network. Here is how to announce a <span class="caps">HTTP</span> server running on port 4321:</p>
<pre><code>var mdns = require('mdns')
  , ad = mdns.createAdvertisement(mdns.tcp('http'), 4321)
  ;
ad.start();</code></pre>
<p>A good place to do this is the <code>'listening'</code> event handler of your <span class="caps">HTTP</span> server. Here is how to browse all <span class="caps">HTTP</span> servers on the local network:</p>
<pre><code>var browser = mdns.createBrowser(mdns.tcp('http'));
browser.on('serviceUp', function(service) {
  console.log("service up: ", service);
});
browser.on('serviceDown', function(service) {
  console.log("service down: ", service);
});
browser.start();</code></pre>
<p>As you can see the browser object is an <code>EventEmitter</code>. For each <span class="caps">HTTP</span> server a <code>'serviceUp'</code> event is emitted. Likewise, if a server disappears <code>'serviceDown'</code> is send. The <code>service</code> object of a <code>'serviceUp'</code> event might look like this:</p>
<pre><code>{ interfaceIndex: 4
, name: 'somehost'
, type: {name: 'http', protocol: 'tcp', subtypes: []}
, replyDomain: 'local.'
, fullname: 'somehost._http._tcp.local.'
, host: 'somehost.local.'
, port: 4321
, addresses: [ '10.1.1.50', 'fe80::21f:5bff:fecd:ce64' ]
}</code></pre>
<p>In fact you might receive more than one event per service instance. That is because dns_sd reports each available network path to a service. Also, note that you might get more (or less) addresses. This depends on the network topology. If you have both a wired and a wireless connection to the same network you will see both addresses on both interfaces (not including IPv6 addresses). The number of IP addresses also depends on the platform and the resolver being used. More on this later.</p>
<p>The <code>name</code> property is not necessarily the host name. It is a user defined string specifically meant to be displayed in the user interface. It only defaults to the host name.</p>
<h3 id="service_types">On service types</h3>
<p>Service type identifiers are strings used to match service instances to service queries. A service type always contains the service name and the protocol. Additionally it may contain one or more subtype identifiers. Here are some examples:</p>
<pre><code>_http._tcp
_osc._udp
_osc._udp,_api-v1,_api-v2</code></pre>
<p>That&#8217;s an awful lot of underscores and punctuation. To make things easier mdns has a helper class, called <code>ServiceType</code> and some utility functions like <code>mdns.tcp(...)</code> in the example above. Here are some ways to create a <code>ServiceType</code> object:</p>
<pre><code>var r0 = mdns.tcp('http')                     // string form: _http._tcp
  , r1 = mdns.udp('osc', 'api-v1')            // string form: _osc._udp,_api-v1
  , r2 = new mdns.ServiceType('http', 'tcp')  // string form: _http._tcp
  , r3 = mdns.makeServiceType('https', 'tcp') // string form: _https._tcp
  ;</code></pre>
<p>Wherever mdns calls for a <code>serviceType</code> argument you can pass a <code>ServiceType</code> object or any of the following representations:</p>
<pre><code>var r0 = '_http._tcp,_api-v1'                                   // string form
  , r1 = ['http', 'tcp', 'api-v1']                              // array form
  , r2 = {name: 'http', protocol: 'tcp', subtypes: ['api-v1']}  // object form
  ;</code></pre>
<p>In fact all of these are legal constructor arguments for <code>ServiceType</code>. <span class="caps">JSON</span> (de-)serialization works too. And finally there is <code>makeServiceType(...)</code> which turns any representation into a <code>ServiceType</code> object unless it already is one.</p>
<h3 id="resolver_sequence">The resolver sequence</h3>
<p>The <code>Browser</code> object uses a resolver sequence to collect address and port information. A resolver sequence is basically just an array of functions. The functions are called in order and receive two arguments: a <code>service</code> object to decorate and a <code>next()</code> function. Each function gathers information on the service, often by invoking asynchronous operations. When done the data is stored on the <code>service</code> object and the next function is invoked by calling <code>next()</code>. This is kind of like web server middleware as it happens between service discovery and emitting the events. On the other hand it is just another async function chain thing.</p>
<p>Resolver sequence tasks (RSTs) are created by calling factory functions:</p>
<pre><code>var sequence = [
    mdns.rst.DNSServiceResolve()
  , mdns.rst.DNSGetAddrInfo({families: [4] })
];</code></pre>
<p>A browser with a custom sequence is created like this:</p>
<pre><code>var browser = mdns.createBrowser(mdns.tcp('http'), {resolverSequence: sequence});</code></pre>
<p>And of course you can write your own tasks:</p>
<pre><code>var MCHammer = function MCHammer() {
  return function MCHammer(service, next) {
    console.log('STOP!');
    setTimeout(function() {
        console.log('hammertime...');
        service.hammertime = new Date();
        next();
    }, 2000);
  }
}</code></pre>
<p>Although it seems a bit complicated this design solves a number of problems:</p>
<ol>
	<li>The default behavior to resolve all services down to the IP is very convenient. But it is very expensive and very time consuming, too. Many applications just don&#8217;t need every port number for every service instance. They just need one. Now it is up to the user to plug together whatever the application requires.</li>
	<li>Portability was another issue. Not all platforms support all functions required by the (old) default behavior. The resolver sequence provides the necessary abstraction to handle this cleanly.</li>
	<li>Something with separation of concerns.</li>
</ol>
<h2 id="reference">Reference</h2>
<p>Many arguments and options in mdns are directly passed to the dns_sd <span class="caps">API</span>. This document only covers the more important features. For in depth information on the <span class="caps">API</span> and how zeroconf service discovery works refer to <a href="#further_reading">Further Reading</a>.</p>
<h3 id="advertisement">mdns.Advertisement</h3>
<p>An <code>Advertisement</code> publishes information about a service on the local network.</p>
<blockquote id="fairydust">
<p id="fairydust">The hack0r takes a good look at the local network, <em>someones</em> local network and sprinkles it with fairydust. He watches the particles being swirled up into vortices originating in the passing network traffic. Datadevils on a parking lot next to the information freeway. Visible entropy. The particles in the vortices are illuminated by open ports and the pale neon light of multicast <span class="caps">DNS</span> service advertisements. The hack0r smiles.</p>
</blockquote>
<h4>new mdns.Advertisement(serviceType, port, [options], [callback])</h4>
<p>Create a new service advertisement with the given <code>serviceType</code> and <code>port</code>. The <code>callback</code> has the arguments <code>(error, service)</code> and it is run after successful registration and if an error occurs. If the advertisement is used without a callback an handler should be attached to the <code>'error'</code> event. The <code>options</code> object contains additional arguments to <code>DNSServiceRegister(...)</code>:</p>
<dl>
	<dt>name</dt>
	<dd>up to 63 bytes of Unicode to be used as the instance name. Think iTunes shared library names. If not given the host name is used instead.</dd>
	<dt>interfaceIndex</dt>
	<dd>one-based index of the network interface the service should be announced on.</dd>
	<dt>txtRecord</dt>
	<dd>is interesting&#8230; but not yet implemented. You can pass a <code>Buffer</code> object but unfortunately there is no way to create it.</dd>
	<dt>host</dt>
	<dd>see documentation of <code>DNSServiceRegister(...)</code></dd>
	<dt>domain</dt>
	<dd>see documentation of <code>DNSServiceRegister(...)</code></dd>
	<dt>flags</dt>
	<dd>see documentation of <code>DNSServiceRegister(...)</code></dd>
	<dt>context</dt>
	<dd>see documentation of <code>DNSServiceRegister(...)</code></dd>
</dl>
<h4>Event: &#8216;error&#8217;</h4>
<pre><code>function onError(exception) {}</code></pre>
<p>Emitted on asynchronous errors.</p>
<h4>ad.start()</h4>
<p>Start the advertisement.</p>
<h4>ad.stop()</h4>
<p>Stop the advertisement.</p>
<h3 id="browser">mdns.Browser</h3>
<p>A <code>mdns.Browser</code> performs the discovery part. It emits events as services appear and disappear on the network. For new services it also resolves host name, port and IP addresses. The <a href="#resolver_sequence">resolver sequence</a> is fully user configurable.</p>
<p>Services are reported for each interface they are reachable on. Partly because that is what dns_sd is doing, partly because anything else would mean making assumptions.</p>
<h4>new mdns.Browser(serviceType, [options])</h4>
<p>Create a new browser to discover services that match the given <code>serviceType</code>. <code>options</code> may contain the following properties:</p>
<dl>
	<dt>resolverSequence</dt>
	<dd>custom <a href="#resolver_sequence">resolver sequence</a> for this browser</dd>
	<dt>interfaceIndex</dt>
	<dd>one-based index of the network interface the services should be discovered on.</dd>
	<dt>domain</dt>
	<dd>see documentation of <code>DNSServiceBrowse(...)</code></dd>
	<dt>context</dt>
	<dd>see documentation of <code>DNSServiceBrowse(...)</code></dd>
	<dt>flags</dt>
	<dd>see documentation of <code>DNSServiceBrowse(...)</code></dd>
</dl>
<h4>Event: &#8216;serviceUp&#8217;</h4>
<pre><code>function onServiceUp(service) {}</code></pre>
<p>Emitted when a new matching service is discovered.</p>
<h4>Event: &#8216;serviceDown&#8217;</h4>
<pre><code>function onServiceDown(service) {}</code></pre>
<p>Emitted when a matching service disappears.</p>
<h4>Event: &#8216;serviceChanged&#8217;</h4>
<pre><code>function onServiceChanged(service) {}</code></pre>
<p>Emitted when a matching service either appears or disappears. It is a new service if <code>service.flags</code> has <code>mdns.kDNSServiceFlagsAdd</code> set.</p>
<h4>Event: &#8216;error&#8217;</h4>
<pre><code>function onError(exception) {}</code></pre>
<p>Emitted on asynchronous errors.</p>
<h4>browser.start()</h4>
<p>Start the browser.</p>
<h4>browser.stop()</h4>
<p>Stop the browser.</p>
<h4>mdns.Browser.defaultResolverSequence</h4>
<p>This is the resolver sequence used by all browser objects that do not override it. It contains two steps. On platforms that have <code>DNSGetAddrInfo(...)</code> it has the following items:</p>
<pre><code>var default_sequence = [
    mdns.rst.DNSServiceResolve()
  , mdns.rst.DNSGetAddrInfo()
  , mdns.rst.makeAddressesUnique()
];</code></pre>
<p>On platforms that don&#8217;t, <code>mdns.rst.getaddrinfo(...)</code> is used instead. You could modify the default sequence but you shouldn&#8217;t.</p>
<h3 id="rst">Resolve sequence tasks</h3>
<h4>mdns.rst.DNSServiceResolve(options)</h4>
<p>Resolve host name and port. Probably all but the empty sequence start with this task. The <code>options</code> object may have the following properties:</p>
<dl>
	<dt>flags</dt>
	<dd>flags passed to <code>DNSServiceResolve(...)</code></dd>
</dl>
<h4>mdns.rst.DNSGetAddrInfo(options)</h4>
<p>Resolve IP addresses using <code>DNSGetAddrInfo(...)</code></p>
<h4>mdns.rst.getaddrinfo(options)</h4>
<p>Resolve IP addresses using nodes <code>cares.getaddrinfo(...)</code>&#8230; but it&#8217;s a mess.</p>
<h4>mdns.rst.makeAddressesUnique()</h4>
<p>Filters the addresses to be unique.</p>
<h4>mdns.rst.filterAddresses(f)</h4>
<p>Filters the addresses by invoking <code>f()</code> on each address. If <code>f()</code> returns false the address is dropped.</p>
<h4>mdns.rst.logService()</h4>
<p>Print the <code>service</code> object.</p>
<h3 id="service_type">mdns.ServiceType</h3>
<p><code>ServiceType</code> objects represent service type identifiers which have been discussed <a href="#service_types">above</a>. They store the required information in a normalized way and help with formating and parsing of these strings.</p>
<h4>new mdns.ServiceType(&#8230;)</h4>
<p>Construct a <code>ServiceType</code> object. When called with one argument the argument may be</p>
<ul>
	<li>a service type identifier</li>
	<li>an array, the first element being the type, the second the protocol. Additional items are <code>subtypes</code>.</li>
	<li>an object with properties <code>name</code>, <code>protocol</code> and optionally <code>subtypes</code></li>
</ul>
<p>All tokens may have a leading underscore. The n-ary form treats its arguments as an array. Copy construction works, too.</p>
<h4>service_type.name</h4>
<p>The primary service type.</p>
<h4>service_type.protocol</h4>
<p>The protocol used by the service. Must be &#8216;tcp&#8217; or &#8216;udp&#8217;.</p>
<h4>service_type.subtypes</h4>
<p>Array of subtypes.</p>
<h4>service_type.toString()</h4>
<p>Convert the object to a service type identifier.</p>
<h4>service_type.fromString(string)</h4>
<p>Parse a service type identifier and store the values.</p>
<h4>service_type.toArray()</h4>
<p>Returns the service type in array form.</p>
<h4>service_type.fromArray(array)</h4>
<p>Set values from an array.</p>
<h4>service_type.fromJSON(obj)</h4>
<p>Set values from object, including other <code>ServiceType</code> objects.</p>
<h3 id="functions">Functions</h3>
<h4>mdns.tcp(&#8230;)</h4>
<p>Expressive way to create a <code>ServiceType</code> with protocol tcp.</p>
<h4>mdns.udp(&#8230;)</h4>
<p>Expressive way to create a <code>ServiceType</code> with protocol udp.</p>
<h4>mdns.makeServiceType(&#8230;)</h4>
<p>Constructs a <code>ServiceType</code> from its arguments. If the first and only argument is a <code>ServiceType</code> it is just returned.</p>
<h4>mdns.createBrowser(serviceType, [options])</h4>
<p>This factory function constructs a <code>Browser</code>.</p>
<h4>mdns.createAdvertisement(serviceType, port, [options], [callback])</h4>
<p>This factory function constructs an <code>Advertisement</code>.</p>
<h4>mdns.browseThemAll(options)</h4>
<p>Creates a browser initialized with the wildcard service type. When started the browser emits events for each <em>service type</em> instead of each service instance. The <code>service</code> objects have no <code>name</code> property. By default the browser has an empty resolver sequence. You still can set one using the <code>options</code> object.</p>
<h3 id="constants">Constants</h3>
<p>All dns_sd constants (supported by the implementation) are exposed on the <code>mdns</code> object. Refer to the <a href="http://developer.apple.com/library/mac/#documentation/Networking/Reference/DNSServiceDiscovery_CRef/dns_sd_h/">dns_sd <span class="caps">API</span> documentation</a> for a list.</p>
<h3 id="dns_sd">mdns.dns_sd</h3>
<p><code>mdns.dns_sd</code> contains the native functions and data structures. The functions are bound to javascript using the exact C names and arguments. This breaks with the usual node convention of lower-case function names.</p>
<h2 id="design_notes">Design Notes</h2>
<p>The implementation has two layers: A low-level <span class="caps">API</span> and a more user friendly object based <span class="caps">API</span>. The low-level <span class="caps">API</span> is implemented in C++ and just wraps functions, data structures and constants from <code>dns_sd.h</code>. Most of the code deals with argument conversion and error handling. A smaller portion deals with callbacks from C(++) to javascript.</p>
<p>The high-level <span class="caps">API</span> is written in javascript. It connects the low-level <span class="caps">API</span> to nodes non-blocking IO infrastructure, namely <code>process.IOWatcher</code>. This results in excellent separation of concerns and leads to a very robust design&#8230; because Ryan is doing all the work.</p>
<h2 id="compatibility">Compatibility Notes</h2>
<h2 id="further_reading">Further Reading</h2>
<ul>
	<li><a href="http://developer.apple.com/library/mac/#documentation/Networking/Reference/DNSServiceDiscovery_CRef/dns_sd_h/">dns_sd <span class="caps">API</span> documentation</a></li>
	<li><a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/NetServices/Introduction.html">Bonjour Overview</a></li>
	<li><a href="http://developer.apple.com/library/mac/#documentation/Networking/Conceptual/dns_discovery_api/Introduction.html"><span class="caps">DNS</span> Service Discovery Programming Guide</a></li>
</ul>

      </div>
    </div>
    <a href="http://github.com/agnat/node_mdns"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://a248.e.akamai.net/assets.github.com/img/edc6dae7a1079163caf7f17c60495bbb6d027c93/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub"></a>
  </body>
</html>

